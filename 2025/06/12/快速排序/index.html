<!DOCTYPE HTML>
<html lang="zh">
<head>
  <meta charset="utf-8">
  
  <title>快速排序 | Internalization</title>
  <meta name="author" content="Gaofeng Peng">
  
  <meta name="description" content="快速排序是技术岗面试手撕的常见题目，原理也很简单，但为什么我还是栽了 :(

快速排序的基本原理是什么？

对于一个数组，从中选择一个数字作为基准，然后将剩下的数字分成比这个数字大的一堆和小的一堆，然后在划分好的两堆中重复上面的操作。
每次划分都可以确定基准的位置。如果基准选得好，每次划分都可以刚好">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="快速排序"/>
  <meta property="og:site_name" content="Internalization"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Internalization</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-快速排序" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2025-06-12T12:05:10.000Z"><a href="/2025/06/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">2025-06-12</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">快速排序</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>快速排序是技术岗面试手撕的常见题目，原理也很简单，但为什么我还是栽了 <code>:(</code></p>
<blockquote>
<p>快速排序的基本原理是什么？</p>
</blockquote>
<p>对于一个数组，从中选择一个数字作为基准，然后将剩下的数字分成比这个数字大的一堆和小的一堆，然后在划分好的两堆中重复上面的操作。</p>
<p>每次划分都可以确定基准的位置。如果基准选得好，每次划分都可以刚好划分成等量的两堆，那么就只需要进行<code>logn</code>次的划分，每次划分需要遍历一次数组，复杂度就是<code>nlogn</code>；但如果每次划分只能得到一堆，也就是基准刚好就是最大值或者最小值，那么就需要<code>n</code>次划分，复杂度就是<code>n^2</code>。</p>
<blockquote>
<p>输入一个int数组，怎么进行快速排序？</p>
</blockquote>
<p>从上面排序原理的介绍，我们很容易想到用递归实现。如果不考虑内存占用，可以考虑使用辅助数组用来存储分好的两堆数字。</p>
<p><em>(当时面试让实现快排，我只记得原理不记得具体实现，就用的这种方式 <code>:(</code>，可惜第一次写这个实现的时候，没有把基准单独拎出来陷入了死循环，菜就多练)</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归跳出条件，只有一个数字不需要排序</span></span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用辅助数组进行划分</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; bigger;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; smaller;</span><br><span class="line">    <span class="type">int</span> pivot=arr.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot) smaller.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">else</span> bigger.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对子数组进行排序</span></span><br><span class="line">    <span class="built_in">qsort</span>(bigger);</span><br><span class="line">    <span class="built_in">qsort</span>(smaller);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将排序好的数组拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;smaller.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        arr[i]=smaller[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[smaller.<span class="built_in">size</span>()]=pivot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bigger.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        arr[i+smaller.<span class="built_in">size</span>()<span class="number">+1</span>]=bigger[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的是类似思路的原地快速排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end-start<span class="number">+1</span>&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivot=arr[start];</span><br><span class="line">    <span class="type">int</span> smallNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot) smallNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pivotIndex=start+smallNum;</span><br><span class="line">    <span class="built_in">swap</span>(arr[start],arr[pivotIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start,j=pivotIndex<span class="number">+1</span>;i&lt;pivotIndex;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot) i++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsort</span>(arr,start, pivotIndex<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">qsort</span>(arr,pivotIndex<span class="number">+1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个实现其实都可以归到一种实现，就是基于数数找到基准的位置，前者是先划分，划分完中间的那个位置就是基准的位置；后者是直接数，确定基准位置后再原地划分。</p>
<p>上面两个实现其实很符合直觉，也很容易理解，现场手撕记得原理就很容易想出来，但第二个实现虽然实现了原地快排，但每次划分需要两次遍历，接下来是经典实现，每次划分只需要一次遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end-start<span class="number">+1</span>&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=start;</span><br><span class="line">    <span class="type">int</span> right=end;</span><br><span class="line">    <span class="type">int</span> pivot=arr[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[right]&gt;=pivot) right--;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left],arr[right]);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[left]&lt;=pivot) left++;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left],arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsort</span>(arr, start, left<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">qsort</span>(arr, left<span class="number">+1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说句实话，我觉得这个实现其实不是很符合直觉，有很多注意点在里面。首先，我们这里选择的是数组首个数字作为基准，但比较推荐随机选择，<code>swap(arr[left],arr[random_index])</code>一下就好了，后续操作是一样的；其次就是<code>while</code>循环里的顺序，因为我们当前指向<code>pivot</code>的是<code>left</code>，所以接下来需要确定<code>right</code>；最后我们就通过一次划分确定了基准的位置。</p>
<blockquote>
<p>以上两种实现的区别是什么？</p>
</blockquote>
<p>以上两种实现都是基于递归，区别点在于每次划分确定基准位置的方式不同。前者就是数数，把小堆数量数出来了，那么基准位置就在<code>arr[samller.size()]</code>；而后者就很妙，后者的基准位置一直在浮动，要么在<code>left</code>指针下，要么在<code>right</code>指针下，两指针外是分好的堆，两指针内是待分的堆，当左右指针相遇时，也就意味着没有需要划分的了，同时，基准位置也确定了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Kommentare</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://peng-gx.github.io/2025/06/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="as_sitesearch" value="peng-gx.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/markdown/">markdown</a><small>1</small></li>
  
  </ul>
</div>


  
  <div class="widget widget-archives">
    <h3 class="title">Archiv</h3>
    <div class="entry">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2025 Gaofeng Peng
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
